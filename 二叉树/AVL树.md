# (数据结构)AVL 详解



## 1.前言-为什么要学习AVL树？

​		我们已经知道，二叉搜索树已经在二叉树的基础上增加了排序，这样的设计可以让我们在遍历二叉树的时候，可以通过对当前结点元素大小的判断，来选择左右子树的遍历方向，而避免了性能消耗在不会存在结果的子树上，可以提高我们的遍历速度。在**理想情况**下，与常规的链表相比，时间复杂度由链表的O(n)优化到了O(logn)。



### 思考

如果我们使用二叉搜索树的目的是提升元素遍历的效率，那么目前的二叉搜索树是否存在问题？什么情况下会出现问题？怎么解决？

------

### 试验

我们对同一组元素，按照不同顺序添加到二叉搜索树中

1.添加顺序:[4,2,6,1,3,5]

![image-20241122112457162](image/image-20241122112457162.png)

2.[1,2,3,4,5,6]

![image-20241122112610917](image/image-20241122112610917.png)

### 结论

我们可以看到对同一组数据，按照不同顺序添加到二叉树后，树的结构有着明显的不同，甚至在最坏的情况下，二叉树已经和链表没有什么区别了，它的时间复杂度退化成成了n(n)

所以，二叉搜索树添加数据时，并不总是处于理想状态下，最坏的情况可能会退化成链表。

### 分析

**原因**：因为二叉搜索树每次添加新元素的时候，是根据已有结点进行大小判断，确定位置后添加，所以如果一开始就把最小的结点添加进去，那么后续的元素都不会添加到根结点的左子树当中，这样就会导致后续的元素只会添加到已有元素的右子树中，到最后，所有元素的结点只有右结点存储了数据，这样的结果显然是我们不愿意看到的。

> 我们理想的情况应该是，每一颗二叉搜索树的根结点是所有元素的中位数，这样才能使高度和左右子树的元素个数趋近于平衡，降低树的高度，避免单一方向地添加元素，使其退化为链表。
>
> 我们显然无法控制添加元素的顺序，所以我们只能想办法，**在数据元素有变化的时候(添加新元素或者删除元素)的时候，调整已有的存储结构，实现一个自平衡的效果**。
>
> 能够实现这样一种功能的二叉搜索树，就是平衡二叉搜索树，**他通过自平衡，避免了上述二叉搜索树的弊端**。



## 2.AVL树的相关概念

AVL树全称是自平衡二叉搜索树，与二叉搜索树不同的是，他实现了自平衡的功能。为了更好地理解自平衡的概念，我们首先来了解一个重要的概念——**平衡因子**。

### 平衡因子

平衡因子简单来说，就是某个结点的左子树的高度与右子树高度的差：	**结点的平衡因子= 左子树的高度 - 右子树的高度**



​	